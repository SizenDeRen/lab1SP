section .data
array db 10011011b, 10111100b, 11101101b, 00101010b, 11010101b, 01010101b, 01111111b, 00000001b, 11111111b, 00000000b, 01010101b, 10101010b
count db 0   ; счетчик количества элементов

section .text
global _start

_start:
    ; обнуляем счетчик
    mov al, 0
    mov [count], al

    ; проходим по элементам массива и проверяем их двоичный код
    mov ecx, 12    ; количество элементов в массиве
    mov esi, array ; загрузка адреса массива в регистр esi
loop_start:
    movzx eax, byte [esi] ; загрузка текущего элемента массива в регистр eax
    test ah, 20h          ; проверка битов 1 и 5
    jnz loop_end          ; переход, если биты не содержат 0

    ; инкремент счетчика
    inc [count]

loop_end:
    add esi, 1   ; инкремент адреса массива
    loop loop_start ; повторяем для каждого элемента в массиве

    ; выводим результат на экран
    mov eax, 4 ; системный вызов для вывода строки на экран
    mov ebx, 1 ; дескриптор файла (stdout)
    mov ecx, msg ; адрес строки с сообщением
    mov edx, len ; длина строки
    int 0x80

    mov eax, 4 ; системный вызов для вывода числа на экран
    mov ebx, 1 ; дескриптор файла (stdout)
    mov ecx, [count] ; значение счетчика
    add ecx, '0' ; преобразование числа в ASCII-код
    mov edx, 1 ; длина строки
    int 0x80

    ; завершение программы
    mov eax, 1 ; системный вызов для выхода из программы
    xor ebx, ebx ; возвращаемое значение 0
    int 0x80

section .data
msg db "Количество элементов, двоичный код которых содержит 0 в битах 1 и 5: ", 0
len equ $-msg ; длина строки